#!/usr/bin/env Rscript 

# Load optparse we need to check inputs

suppressPackageStartupMessages(require(optparse))
suppressPackageStartupMessages(require(workflowscriptscommon))

# parse options

option_list = list(
  make_option(
    c("-s", "--samples"),
    action = "store",
    default = NA,
    type = 'character',
    help = "A comma-separated list containing one or more directory names, each
            corresponding to a 10X sample. Each directory should contain the 'matrix.mtx',
            'genes.tsv' and 'barcodes.tsv' files generated by CellRanger. 
            Alternatively, strings may contain a path to a HDF5 file in the sparse
            matrix format generated by 10X. These can be mixed with directory 
            names when type='auto'."
  ),
  make_option(
    c("-c", "--col-names"),
    action = "store",
    default = FALSE,
    type = 'logical',
    help = "A logical scalar indicating whether the columns of the output object
            should be named with the cell barcodes."
  ),
  make_option(
    c("-m", "--metadata-files"),
    action = "store",
    default = NA, 
    type = 'character',
    help = "A comma-separated list containing one or more paths to 
            metadata files in .txt format, e.g. with cell type annotations.
            Note that gene ids must be consistent across the files 
            and correspond to the matrix data."
  ),
  make_option(
    c("-f", "--metadata-columns"),
    action = "store",
    default = NA,
    type = "character",
    help = "A comma-separated list of metadata file field names that should be
            added to the SCE object. By default, all columns are kept."
  ),
  make_option(
    c("-b", "--cell-id-column"),
    action = "store",
    default = NA, 
    type = "character", 
    help = "Name of the metadata file column that corresponds to the unique identifier
            of each cell in the dataset (e.g. barcode). Must correspond to column names in
            the 10X directory."
  ),
  make_option(
    c("-o", "--output-object-file"),
    action = "store",
    default = NA,
    type = 'character',
    help = "File name in which to store serialized SingleCellExperiment object."
  )
)

opt <- wsc_parse_args(option_list, mandatory = c('samples', 'output_object_file'))

# Now we're hapy with the arguments, load DropletUtils and do the work
suppressPackageStartupMessages(require(DropletUtils))

# Parse out multiple directories from the samples string
samples <- wsc_split_string(opt$samples)

# Derive the SingleCellExperiment
single_cell_experiment <- read10xCounts( samples = samples, col.names = opt$col_names )

# metadata file logic 
if(!is.na(opt$metadata_files)){
  metadata_files = wsc_split_string(opt$metadata_files)

  # check cell id column is provided
  if(is.na(opt$cell_id_column)){
    stop("Cell id column name for metadata files is not provided.")
  }
  metadata = lapply(metadata_files, function(x) 
                                    read.csv(x, sep="\t",
                                    check.names=FALSE,
                                    stringsAsFactors=FALSE))
  common_names = Reduce(intersect, lapply(metadata, colnames))
  metadata = do.call(rbind, lapply(metadata, function(x) x[,common_names]))

  # remove technical duplicate rows
  metadata = metadata[which(!duplicated(metadata[, opt$cell_id_column])), ]

  # keep only selected columns, if specified 
  if(!is.na(opt$metadata_columns)){
    metadata_columns = wsc_split_string(opt$metadata_columns)
    if(!all(metadata_columns %in% colnames(metadata))){
      stop("Provided metadata column names do not match existing names.")
    } 
    # subset by given columns
    metadata = metadata[, metadata_columns]
  }

  # Check that all the cells have annotations
  if (! all(colData(single_cell_experiment)$Barcode %in% metadata[[opt$cell_id_column]])){
    stop("Error in matching metadata to expression matrix columns.")
  }else{
    savednames <- rownames(colData(single_cell_experiment))
    colData(single_cell_experiment) <- merge(colData(single_cell_experiment), metadata, by.x = 'Barcode', by.y = opt$cell_id_column, sort = FALSE)
    rownames(colData(single_cell_experiment)) <- savednames
  }
}

# Print object summary
cat(c(
  '# Object summary', 
  capture.output(print(single_cell_experiment)), 
  '\n# Metadata sample', 
  capture.output(head(colData(single_cell_experiment)))
), 
sep = '\n')

# Output to a serialized R object
saveRDS(single_cell_experiment, file = opt$output_object_file)
